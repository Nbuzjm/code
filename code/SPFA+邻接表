int dis[N],nxt[M],to[M],w[M],head[N];
int n,m,s;
queue<int> q;
int tot=0;
bool vis[N];
void add(int x,int y,int z){
	nxt[++tot]=head[x];
	head[x]=tot;
	w[tot]=z;
	to[tot]=y;
}
void spfa(int u){
	q.push(u);
	vis[u]=1;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=nxt[i]){
			int y=to[i];
			if(dis[x]+w[i]<dis[y]){
				dis[y]=dis[x]+w[i];
				if(!vis[y])
				vis[y]=1,q.push(y);//如果加入cnt记录每个点的入队次数，如果次数>=n即确定存在负环
			}
		}
	}
}
int main(){
	n=read();m=read();s=read();
	int i,j,k;
	for(i=1;i<=m;++i)
	{
		int x,y,z;
		x=read();y=read();z=read();
		add(x,y,z);
		//add(read(),read(),read());不能直接这样写
	}
	for(i=1;i<=n;++i)
	{
		dis[i]=2147483647;//这是模板题要求的大小，一般情况下设为极大值即可
		vis[i]=0;
	}
	dis[s]=0;
	spfa(s);
	for(i=1;i<=n;++i)
		printf("%d ",dis[i]);
	return 0;
}