#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=3e5+7;
int root[maxn],tot;
int m;
int a[maxn],b[maxn];
void quchong(int n){
	sort(b+1,b+1+n);
	m=unique(b+1,b+1+n)-b-1;
}
int getid(int x){
	return lower_bound(b+1,b+1+m,x)-b;
}
struct Tree{
	int lc,rc;
	int sum;
}tree[maxn*20];
void pushup(int k){
	tree[k].sum=tree[tree[k].lc].sum+tree[tree[k].rc].sum;
}
int build(int l,int r){
	int k=++tot;
	tree[k].sum=0;
	if(l==r) return k;
	int mid=(l+r)>>1;
	tree[k].lc=build(l,mid);
	tree[k].rc=build(mid+1,r);
	return k;
}

int updata(int p,int id,int v,int l,int r){
	int k=++tot;
	tree[k]=tree[p];
	if(l==r){
		tree[k].sum+=v;
		return k;
	}
	int mid=(l+r)>>1;
	if(id<=mid) tree[k].lc=updata(tree[p].lc,id,v,l,mid);
	else tree[k].rc=updata(tree[p].rc,id,v,mid+1,r);
	pushup(k);
	return k;
}

/*
    相当于在第R棵线段树上找满足条件的数字和,
    如果要递归到左子树的话,那么右子树代表[L,R] 必定都满足答案;
    如果要递归到右子树的话,左子树代表的数字其位置均小于L故不可加左子树;
*/
int myfind(int p,int id,int l,int r){
	if(l==r) return tree[p].sum;
	int mid=(l+r)>>1;
	if(id<=mid) return tree[tree[p].rc].sum+myfind(tree[p].lc,id,l,mid);
	return myfind(tree[p].rc,id,mid+1,r);

}
int belong[maxn];
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
		b[i] = a[i];
	}
	int l, r;
	quchong(n);
	int q;
	root[0] = build(1, n);
	for (int i = 1; i <= n; ++i) {
		int id = getid(a[i]);
		if (belong[id]) {
			int t = updata(root[i - 1], belong[id], -1, 1, n);
			root[i] = updata(t, i, 1, 1, n);
		}
		else {
			root[i] = updata(root[i - 1], i, 1, 1, n);
		}
		belong[id] = i;
	}

	scanf("%d", &q);
	while (q--) {
		scanf("%d%d", &l, &r);
		printf("%d\n", myfind(root[r], l, 1, n));
	}
	return 0;
}