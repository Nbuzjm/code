struct Linear{
	std::vector<int> p;//32就够了
	void insert(int x)
	{
		if(p.size()>=32) return;
		for(int i=p.size()-1;~i;i--)
		{
			if((x^p[i])<x)
			    x^=p[i];
			else
			    if(p[i]<x)
			    break;
		}

		if(x){
			p.push_back(x);
			for(int i=p.size()-1;i&&p[i]<p[i-1];i--)
			std::swap(p[i],p[i-1]);
		}
	}
	int quemx(){
		int ans=0;
		for(int i=p.size()-1;~i;i--)
			ans=std::max(ans,ans^p[i]);
		return ans;
	}
	void merge(const Linear & s)//暴力合并
	{
		for(int i=s.p.size()-1;~i;i--) insert(s.p[i]);
	}
}ze;//空的线性基


basic线性基：
void add(ll x)
{
    for(int i=60;i>=0;i--)
    {
        if(x&(1ll<<i))//注意，如果i大于31，前面的1的后面一定要加ll
        {
            if(d[i])x^=d[i];
            else
            {
                d[i]=x;
                break;//插入成功就退出
            }
        }
    }
}

ll ans()//Max
{
    ll anss=0;
    for(int i=60;i>=0;i--)//记得从线性基的最高位开始
    if((anss^d[i])>anss)anss^=d[i];
    return anss;
 }

void work()//处理线性基
{
	for(int i=1;i<=60;i++)
	for(int j=1;j<=i;j++)
	if(d[i]&(1ll<<(j-1)))d[i]^=d[j-1];
}
ll k_th(ll k)
{
	if(k==1&&tot<n)return 0;//特判一下，假如k=1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度
	if(tot<n)k--;//类似上面，去掉0的情况，因为线性基中只能异或出不为0的解
	work();
	ll ans=0;
	for(int i=0;i<=60;i++)
	if(d[i]!=0)
	{
		if(k%2==1)ans^=d[i];
		k/=2;
	}
}