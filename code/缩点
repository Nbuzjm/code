//采蘑菇
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int nw,nxt,mark;
}pre[100010];
int n,m,idx,cnt;
int dfn[10010],low[10010];
int in[10010],v[10010],fa[10010];
int head[10010];
bool used[10010];
int stk[10010],p;
int ans=0;
void add (int x,int y,int cnt)
{
	pre[cnt].nw=x;
	pre[cnt].mark=head[x];
	pre[cnt].nxt=y;
	head[x]=cnt;
}
void tarjan (int u)
{
	dfn[u]=low[u]=++idx;
	stk[++p]=u;
	used[u]=1;
	for (int i=head[u];i!=0;i=pre[i].mark)
	{
		int nx=pre[i].nxt;
		if (!dfn[nx])
		{
			tarjan (nx);
			low[u]=min (low[u],low[nx]);
		}
		else if (used[nx])
			low[u]=min (low[u],dfn[nx]);
	}
	if (low[u]==dfn[u])
	{
		do{
			v[u]+=v[stk[p]];
			fa[stk[p]]=u;
			used[stk[p]]=0;
			p--;
		}while (stk[p+1]!=u);
		v[u]>>=1;
	}
}
int topo ()
{
	int dis[10010];
	queue<int>q;
	for (int i=1;i<=n;i++)
		if (fa[i]==i)
		{
			dis[i]=v[i];
			if (!in[i])
				q.push(i);
		}
	while (!q.empty())
	{
		int Now=q.front();
		for (int i=head[Now];i!=0;i=pre[i].mark)
		{
			int Nxt=pre[i].nxt;
			dis[Nxt]=max (dis[Nxt],dis[Now]+v[Nxt]);
			in[Nxt]--;
			if (!in[Nxt])
				q.push (Nxt);
		}
		q.pop();
	}
	int maxx=0;
	for (int i=1;i<=n;i++)
		if (fa[i]==i)
			maxx=max (maxx,dis[i]);
	return maxx;
}
int main()
{
	memset (in,0,sizeof (in));
	memset (used,0,sizeof (used));
	memset (dfn,0,sizeof(dfn));
	memset (head,0,sizeof (head));
	scanf ("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		scanf ("%d",&v[i]);
	for (int i=1;i<=m;i++)
	{
		int a,b;
		scanf ("%d%d",&a,&b);
		add (a,b,i);
	}
	for (int i=1;i<=n;i++)
		if (!dfn[i])
			tarjan (i);
	memset (head,0,sizeof (head));
	for (int i=1;i<=m;i++)
	{
		int Now=fa[pre[i].nw];
		int Nxt=fa[pre[i].nxt];
		if (Now!=Nxt)
		{
			add (Now,Nxt,++cnt);
			in[Nxt]++;
		}
	}
	printf ("%d",topo ());
	return 0;
}

# 采蘑菇
#include<bits/stdc++.h>
using namespace std;
#define M 500000
typedef long long ll;
typedef unsigned long long ull;
inline ll read() {
	char ch;
	ll f = 1, res = 0;
	while ((ch = getchar()) < '0' || ch > '9')
		if (ch == '-') f = -1;
	while (ch >= '0' && ch <= '9') {
		res = (res << 1) + (res << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * res;
}
inline void pt(ll u,ll mod) {
	printf("%lld", u);
	if (mod == 1)
		putchar(' ');
	else if (mod == 2)
		putchar('\n');
}

ll m,n;
ll st;
ll dfsTime[M];
ll minTime[M];
ll clk=1;
ll head[M];
ll v[M];
ll type[M];
ll f[M];
ll gap=1;

struct node {
	ll from;
	ll to;
	ll one;
	ll all;
	ll next;
}e[M];
stack<ll>stk;

void tar(ll inx) {
	dfsTime[inx] = minTime[inx] = clk++;
	type[inx] = gap;
	stk.push(inx);
	for (ll i = head[inx]; i; i = e[i].next) {
		ll p = e[i].to;
		if (!dfsTime[p]) {
			tar(p);
			minTime[inx] = min(minTime[inx], minTime[p]);
		}
		else if (type[p] == gap) {
			minTime[inx] = min(minTime[inx], minTime[p]);
		}
	}

	vector<ll> op;
	if (dfsTime[inx] == minTime[inx]) {
		while (true) {
			ll u = stk.top();
			f[u] = inx;
//			cout<<u<<':'<<v[u]<<endl;
			if(u!=inx)
				v[inx]+=v[u];
			op.push_back(u);
			stk.pop();
			if (u == inx) {
				break;
			}
		}
	}

	for (auto u:op) {
		for (ll i = head[u]; i; i = e[i].next) {
			ll p = e[i].to;
			if (f[p] == inx) {
				v[inx] += e[i].all;
			}
		}
		type[u] = 0;
	}

}

bool vis[M]={false};
void spfa(ll s) {
	queue<ll> op;
	op.push(s);
	while (!op.empty()) {
		ll t = op.front();
		op.pop();
		for (ll i = head[t]; i; i = e[i].next) {
			ll p = e[i].to;
			if (v[t] + e[i].one > v[p]) {
				v[p] = v[t] + e[i].one;
				if (!vis[p]) {
					op.push(p);
					vis[p] = true;
				}
			}
		}
		vis[t] = false;
	}
}
int main() {
	//freopen("../in", "r", stdin);
	//freopen("../out", "w", stdout);
	m = read(), n = read();
	ll a, b, c;
	double d;
	for (ll i = 1; i <= n; i++) {
		a = read(), b = read(), c = read();
		scanf("%lf", &d);
		e[i].from = a;
		e[i].to = b;
		ll sum = 0;
		e[i].one = c;
		e[i].next = head[a];

		while (c) {
			sum += c;
			c = c * d;
		}
		e[i].all = sum;
		if (a == b) {
			v[a] += sum;
		}
		else {
			head[a] = i;
		}
	}
	st = read();
	for (ll i = 1; i <= m; i++) {
		gap = i;
		if (!minTime[i])
			tar(i);
	}

	memset(head, 0, sizeof(head));
	ll num = 1;
	for (ll i = 1; i <= n; i++) {
		if (f[e[i].from] != f[e[i].to]) {
			e[num].from = f[e[i].from];
			e[num].to = f[e[i].to];
			e[num].one = e[i].one;
			e[num].next = head[f[e[i].from]];
			head[f[e[i].from]] = num++;
		}
	}
	spfa(f[st]);
	ll ans = 0;
	for (ll i = 1; i <= m; i++) {
		ans = max(ans, v[i]);
	}
	pt(ans, 2);
	return 0;
}